BST = function() {
  this.root = null;
	this.num = null;
  //True if duplicate value is passed into tree 
  this.dubBool = false;

  function height(node) {
    if (node == null) {
      return 0;
    }
    return node.height;
  };


  // how many duplicates are less than or equal to a value in the tree
  //
  function dubs(node) {
    if (node == null) {
      return 0;
    }
    return node.dubs;
  }

  function size(node) {
    if (node == null)
      return 0;

    return node.size;
  }

  //Changes a leftchild to be higher node, and current node to rightchild
  var rightRotate = function(y) {



    let x = y.leftchild;


    let right = x.rightchild;

    // rotation
    x.rightchild = y;
    y.leftchild = right;

    y.height = Math.max(height(y.leftchild), height(y.rightchild)) + 1;
    x.height = Math.max(height(x.rightchild), height(x.leftchild)) + 1;

    y.size = size(y.leftchild) + size(y.rightchild) + 1;
    x.size = size(x.leftchild) + size(x.rightchild) + 1;


    //sutracts the rotated node's duplicate count by parent count
    y.dubs -= x.dubs;
    return x;

  };
  //parent becomes leftchild, parent's rightchild becomes the parent. rightchild's leftchild becomes old parent's rightchild.
  var leftRotate = function(x) {


    let y = x.rightchild;
    let left = y.leftchild;


    //rotation

    y.leftchild = x;

    x.rightchild = left;

    x.height = Math.max(height(x.leftchild), height(x.rightchild)) + 1;
    y.height = Math.max(height(y.leftchild), height(y.rightchild)) + 1;


    x.size = size(x.leftchild) + size(x.rightchild) + 1;
    y.size = size(y.leftchild) + size(y.rightchild) + 1;

    //new parent adds duplicate count of old parent to self.
    y.dubs = y.dubs + x.dubs;


    return y;
  }

  function getBalance(node) {
    if (node == null) {
      return 0;
    }

    return height(node.leftchild) - height(node.rightchild);
  }



  this.add = function(node, arr,index) {
		arr[index] = 0;
    if (node == null) {

      return new Node(this.num);
    };

    if (this.num < node.num) {
      node.leftchild = this.add(node.leftchild, arr,index);
      // duplicate count of ancestor rightparents increased by 1
      if (this.dubBool) {
        node.dubs += 1;
      };
    }
    else if (this.num > node.num) {

      node.rightchild = this.add(node.rightchild, arr,index);
      // how many smaller numbers seen so far
      
      arr[index] += size(node.leftchild) + dubs(node) + 1;
     
    } else {
    	//duplicate value
      node.dubs += 1;
   
      arr[index] += size(node.leftchild) + dubs(node.leftchild);
   
      this.dubBool = true;
    
      return node;
    }
    
   

    node.height = Math.max(height(node.leftchild), height(node.rightchild)) + 1;
    node.size = size(node.leftchild) + size(node.rightchild) + 1;

    let balance = getBalance(node);

    if (balance > 1 && this.num < node.leftchild.num) {

      return rightRotate(node);
    }

    if (balance < -1 && this.num > node.rightchild.num) {

      return leftRotate(node);
    }

    if (balance > 1 && this.num > node.leftchid.num) {

      node.leftchild = leftRotate(node.leftchild);
      return rightRotate(node);

    }
    if (balance < -1 && this.num < node.rightchild.num) {

      node.rightchild = rightRotate(node.rightchild);
      return leftRotate(node);
    }


    return node;
  };







  var Node = function(num) {
    this.num = num;
    this.leftchild = null;
    this.rightchild = null;
    this.height = 1;
    this.size = 1;

    //Amount of duplicates that are less than or equal to node value
    this.dubs = 0;

  }
};

// Function that creates the tree and adds elements of array from back adding # of smaller elements in new array.
function smaller(arr) {
  var bst = new BST();
  
  //var smallerArray = new Array(arr.length).fill(0);
  
  for (var i = arr.length - 1; i >= 0; i--) {
    bst.dubBool = false;
    bst.num = arr[i];
    bst.root = bst.add(bst.root, arr, i);
  }

  return arr;

}
